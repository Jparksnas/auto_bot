# main.py (Î¶¨Ìå©ÌÜ†ÎßÅ ÏôÑÎ£åÎ≥∏ - ÏïΩ 800~1000Ï§Ñ)
"""
Upbit ÏûêÎèôÎß§Îß§ Î¥á (Î™®ÎìàÌôî Î≤ÑÏ†Ñ)
Î©îÏù∏ Ïã§Ìñâ Ïä§ÌÅ¨Î¶ΩÌä∏ - Ïò§ÏºÄÏä§Ìä∏Î†àÏù¥ÏÖò Î†àÏù¥Ïñ¥
"""
# ============================================================
# 1. ÌëúÏ§Ä ÎùºÏù¥Î∏åÎü¨Î¶¨ Import
# ============================================================
import asyncio
import ssl
import time as _time
import logging
from logging.handlers import TimedRotatingFileHandler, RotatingFileHandler
from collections import defaultdict, deque
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Optional
import certifi
import json
import sys
import os
from pathlib import Path
from threading import Timer
import sqlite3 

# ============================================================
# SQLite Î°úÍ∑∏ Ìï∏Îì§Îü¨ (Ï∂îÍ∞Ä)
# ============================================================
class SQLiteHandler(logging.Handler):
    """SQLite Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Î°úÍ∑∏Î•º Ï†ÄÏû•ÌïòÎäî Ìï∏Îì§Îü¨"""
    def __init__(self, db_path):
        super().__init__()
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.cursor = self.conn.cursor()
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp REAL,
                level TEXT,
                message TEXT
            )
        ''')
        self.conn.commit()

    def emit(self, record):
        try:
            log_entry = self.format(record)
            self.cursor.execute(
                "INSERT INTO logs (timestamp, level, message) VALUES (?, ?, ?)",
                (record.created, record.levelname, log_entry)
            )
            self.conn.commit()
        except Exception:
            self.handleError(record)

    def close(self):
        self.conn.close()
        super().close()

# ============================================================
# 0. Î°úÍ∑∏ Ìè¥Îçî ÏÉùÏÑ± Î∞è ÏΩòÏÜî Ï∂úÎ†• ÏÑ§Ï†ï
# ============================================================
# Î°úÍ∑∏ Ìè¥Îçî ÏÉùÏÑ±
LOG_DIR = Path("log")
LOG_DIR.mkdir(exist_ok=True)

class Tee:
    """ÏΩòÏÜîÍ≥º ÌååÏùºÏóê ÎèôÏãú Ï∂úÎ†•ÌïòÎäî ÌÅ¥ÎûòÏä§"""
    def __init__(self, *files):
        self.files = files
    
    def write(self, data):
        for f in self.files:
            try:
                f.write(data)
                f.flush()
            except Exception:
                pass
    
    def flush(self):
        for f in self.files:
            try:
                f.flush()
            except Exception:
                pass

# ÏΩòÏÜî Ï∂úÎ†• ÌååÏùº Í≤ΩÎ°ú (log Ìè¥Îçî ÎÇ¥)
timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
console_log_path = LOG_DIR / f"console_{timestamp}.txt"
console_file = open(console_log_path, 'w', encoding='utf-8', buffering=1)

# ÏõêÎûò stdout Î∞±ÏóÖ
_original_stdout = sys.stdout
_original_stderr = sys.stderr

# ÏΩòÏÜîÍ≥º ÌååÏùºÏóê ÎèôÏãú Ï∂úÎ†•
sys.stdout = Tee(_original_stdout, console_file)
sys.stderr = Tee(_original_stderr, console_file)

print(f"[ÏãúÏûë] ÏΩòÏÜî Ï∂úÎ†•Ïù¥ {console_log_path}ÏóêÎèÑ Ï†ÄÏû•Îê©ÎãàÎã§.")

# ============================================================
# 2. Ïô∏Î∂Ä ÎùºÏù¥Î∏åÎü¨Î¶¨ Import
# ============================================================
import pyupbit
import websockets
import aiohttp

# ============================================================
# 3. ÎÇ¥Î∂Ä Î™®Îìà Import (ÏÉàÎ°ú Î∂ÑÌï†Îêú Î™®ÎìàÎì§)
# ============================================================
from modules.config_manager import config
from modules.indicators import Indicators as ind
from modules.market_data import MarketData
from modules.order_manager import OrderManager
from modules.position_manager import PositionManager
from modules.risk_control import RiskControl
from utils.utils import Utils

# ============================================================
# 4. Í∏∞Ï°¥ ÌîÑÎ°úÏ†ùÌä∏ Î™®Îìà Import
# ============================================================
from modules.message_bot import Message_Bot
from modules.mongodb_connect import MongodbConnect
from modules.market_analyzer import MarketAnalyzer
from modules.strategy_engine import decide_order, RiskManager
try:
    from modules.ai_filter import AISignal, extract_features
    AI_AVAILABLE = True
except ImportError:
    AI_AVAILABLE = False
    AISignal = None

DEBUG_ON_DURATION = 120  # Ïò§Î•ò Î∞úÏÉù Ïãú DEBUG Î™®Îìú ÌôúÏÑ±Ìôî ÏßÄÏÜç ÏãúÍ∞Ñ(Ï¥à)
debug_timer = [None]     # Î¶¨Ïä§Ìä∏Î°ú Í∞êÏã∏ÏÑú nonlocalÎ°ú ÏÇ¨Ïö©

# ============================================================
# 5. Î°úÍπÖ ÏÑ§Ï†ï
# ============================================================
def setup_logging():
    """Î°úÍπÖ ÏÑ§Ï†ï (ÏΩòÏÜî ÏµúÏÜåÌôî + ÌååÏùº ÏÉÅÏÑ∏ + SQLite DB)"""
    log_format = '%(asctime)s [%(levelname)s] %(message)s'
    date_format = '%Y-%m-%d %H:%M:%S'
    
    # ===== ÏΩòÏÜî: WARNING Ïù¥ÏÉÅÎßå =====
    console_handler = logging.StreamHandler(_original_stdout)
    console_handler.setLevel(logging.WARNING)
    console_formatter = logging.Formatter('%(levelname)s | %(message)s')
    console_handler.setFormatter(console_formatter)
    
    # ===== ÌååÏùº1: INFO Ïù¥ÏÉÅ (ÏùºÎ≥Ñ Î°úÌÖåÏù¥ÏÖò) =====
    file_handler = TimedRotatingFileHandler(
        LOG_DIR / 'trading_bot.log',
        when='midnight',
        interval=1,
        backupCount=7,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(logging.Formatter(log_format, date_format))
    
    # ===== ÌååÏùº2: ÌïµÏã¨ Ïù¥Î≤§Ìä∏Îßå (Îß§Ïàò/Îß§ÎèÑ Ïã§Ìñâ, TP/SL) =====
    today = datetime.now().strftime('%Y%m%d')
    critical_log_path = LOG_DIR / f"critical_trades_{today}.txt"
    critical_handler = logging.FileHandler(critical_log_path, encoding='utf-8')
    critical_handler.setLevel(logging.WARNING)  # WARNING Ïù¥ÏÉÅÎßå
    critical_handler.setFormatter(logging.Formatter(log_format, date_format))
    
    # ===== SQLite DB: Ï†ÑÏ≤¥ Î°úÍ∑∏ (INFO Ïù¥ÏÉÅ Î™®Îëê Ï†ÄÏû•) =====
    db_path = LOG_DIR / f"trading_log_{today}.db"
    sqlite_handler = SQLiteHandler(db_path)
    sqlite_handler.setLevel(logging.INFO)
    sqlite_handler.setFormatter(logging.Formatter(log_format, date_format))
    
    # ===== ÎîîÎ≤ÑÍ∑∏ Î™®Îìú ÌôúÏÑ±Ìôî Ìï®Ïàò =====
    DEBUG_ON_DURATION = 120
    debug_timer = [None]
    
    def activate_debug_mode():
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)
        for h in logger.handlers:
            if isinstance(h, (logging.FileHandler, SQLiteHandler)):
                h.setLevel(logging.DEBUG)
        print(f"[ALERT] DEBUG Î™®Îìú ÌôúÏÑ±Ìôî (INFO‚ÜíDEBUG)")
        
        def revert_level():
            logger.setLevel(logging.INFO)
            for h in logger.handlers:
                if isinstance(h, (logging.FileHandler, SQLiteHandler)):
                    h.setLevel(logging.INFO)
            print(f"[ALERT] DEBUG Î™®Îìú Ìï¥Ï†ú (DEBUG‚ÜíINFO)")
        
        if debug_timer[0]:
            debug_timer[0].cancel()
        debug_timer[0] = Timer(DEBUG_ON_DURATION, revert_level)
        debug_timer[0].start()
    
    # ===== Î°úÍ±∞ ÏÑ§Ï†ï =====
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    logger.handlers = []
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    logger.addHandler(critical_handler)
    logger.addHandler(sqlite_handler)  # SQLite Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä
    
    logger.activate_debug_mode = activate_debug_mode
    
    # ===== Îß§Îß§ ÌåêÎã® Ï†ÑÏö© Î°úÍ±∞ Ï∂îÍ∞Ä =====
    trade_logger = logging.getLogger('trade_decision')
    trade_logger.setLevel(logging.INFO)
    trade_logger.propagate = False  # Î©îÏù∏ Î°úÍ±∞Î°ú Ï†ÑÌåå Î∞©ÏßÄ
    
    # CSV ÌååÏùº Ìï∏Îì§Îü¨ (Îß§Ïùº Î°úÌÖåÏù¥ÏÖò)
    today = datetime.now().strftime("%Y%m%d")
    trade_log_path = LOG_DIR / f'trading_decision_{today}.csv'
    trade_handler = logging.FileHandler(trade_log_path, encoding='utf-8')
    trade_handler.setFormatter(logging.Formatter('%(asctime)s,%(message)s', datefmt='%Y-%m-%d %H:%M:%S'))
    trade_logger.addHandler(trade_handler)
    
    logger.info(f"üìä Îß§Îß§ ÌåêÎã® Î°úÍ∑∏: {trade_log_path}")
    
    return logger

logger = setup_logging()
logger.info("=" * 60)
logger.info("ÏûêÎèôÎß§Îß§ Î¥á Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
logger.info(f"Ï†ÑÎûµ Î™®Îìú: {config.STRATEGY_MODE}")
logger.info(f"Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®: {config.RISK_LEVEL}")
logger.info("=" * 60)

# ===== Îß§Îß§ ÌåêÎã® Î°úÍ±∞ ÏÑ†Ïñ∏ =====
trade_logger = logging.getLogger('trade_decision')

# CSV Ìó§Îçî ÏûëÏÑ± (Ï≤´ Ïã§Ìñâ Ïãú)
today = datetime.now().strftime("%Y%m%d")
trade_log_path = LOG_DIR / f'trading_decision_{today}.csv'
if not trade_log_path.exists() or trade_log_path.stat().st_size == 0:
    with open(trade_log_path, 'w', encoding='utf-8') as f:
        f.write("timestamp,action,ticker,price,qty,value,reason,strategy,rsi,macd,signal,bb_upper,bb_mid,bb_lower,volume_ratio,pnl_pct,pnl_krw,entry,tp,sl\n")

# ============================================================
# 6. Rate Limiter ÌÅ¥ÎûòÏä§
# ============================================================
class RateLimiter:
    """API Rate Limiting"""
    def __init__(self, max_calls: int, period: float):
        self.max_calls = max_calls
        self.period = period
        self.call_times = deque()
        self.lock = asyncio.Lock()
    
    async def acquire(self, n: int = 1):
        async with self.lock:
            now = _time.time()
            
            # Ïò§ÎûòÎêú Ìò∏Ï∂ú Ï†úÍ±∞
            while self.call_times and now - self.call_times[0] > self.period:
                self.call_times.popleft()
            
            # Rate limit ÎåÄÍ∏∞
            if len(self.call_times) + n > self.max_calls:
                wait = self.period - (now - self.call_times[0])
                if wait > 0:
                    await asyncio.sleep(wait)
            
            # Í∏∞Î°ù
            for _ in range(n):
                self.call_times.append(_time.time())

# ============================================================
# 7. Î©îÏù∏ Î¥á ÌÅ¥ÎûòÏä§
# ============================================================
class TradingBot:
    """ÏûêÎèôÎß§Îß§ Î¥á Î©îÏù∏ ÌÅ¥ÎûòÏä§"""
    
    def __init__(self):
        self.KST = ZoneInfo('Asia/Seoul')
        self.config = config  # config_managerÏùò config Ïù∏Ïä§ÌÑ¥Ïä§
        self.start_time = datetime.now(self.KST)
        
        # API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
        self.upbit = pyupbit.Upbit(config.UPBIT_ACCESS_KEY, config.UPBIT_SECRET_KEY)
        
        # HTTP ÏÑ∏ÏÖò
        self.http_session = None
        self.http_rate = RateLimiter(max_calls=config.MAX_RPS, period=1.0)
        
        # Î©îÏã†Ï†Ä
        self.messenger = Message_Bot(config.TELEGRAM_TOKEN, config.TELEGRAM_CHAT_ID)
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§
        self.db = None
        if getattr(config, 'USE_MONGODB', False):  # ‚Üê Ïù¥Ï†Ñ ÏàòÏ†ïÏÇ¨Ìï≠
            try:
                self.db = MongodbConnect()
            except Exception as e:
                logger.warning(f"MongoDB Ïó∞Í≤∞ Ïã§Ìå®: {e}")
        
        # Î™®Îìà Ï¥àÍ∏∞Ìôî (Î∂ÑÌï†Îêú Î™®ÎìàÎì§)
        self.market_data = None
        self.order_mgr = None
        self.pos_mgr = None
        self.risk_ctrl = None
        
        # Í∏∞Ï°¥ Î™®Îìà
        self.market_analyzer = MarketAnalyzer()
        self.risk_manager = RiskManager()  # ‚Üê ÏàòÏ†ï: Ïù∏Ïûê Ï†úÍ±∞
        
        # AI ÌïÑÌÑ∞
        self.ai_signal = AISignal() if AI_AVAILABLE else None
        
        # ÏÉÅÌÉú Í¥ÄÎ¶¨
        self.universe = []  # Í±∞Îûò Ïú†ÎãàÎ≤ÑÏä§
        self.hold = {}  # Î≥¥Ïú† Ìè¨ÏßÄÏÖò
        self.balance = 0.0
        self.ws_connected = False
        self.last_sync_ts = 0.0
        
        # WebSocket Ï∫êÏãú
        self.ws_price_cache = {}
        self.ws_orderbook_cache = {}
        
        # Î©îÌä∏Î¶≠
        self.metrics = defaultdict(int)
        
        # ÏûëÏóÖ ÌÅê
        self.signal_queue = asyncio.Queue(maxsize=100)
        
        self.ws_reconnect_needed = False
        self.error_counter = defaultdict(int)    # Ïòà: orderbook Ïò§Î•ò Îì± Î∞òÎ≥µ Î©îÏãúÏßÄ Ïπ¥Ïö¥ÌÑ∞
        self.last_error_log_time = defaultdict(float)  # ÎßàÏßÄÎßâ ÏöîÏïΩ Î°úÍ∑∏ ÏãúÏ†ê
        self.errorcounter = defaultdict(int)  # Î∞òÎ≥µ Ïò§Î•ò Ïπ¥Ïö¥ÌÑ∞
        self.lasterrorlogtime = defaultdict(float)  # ÎßàÏßÄÎßâ ÏöîÏïΩ Î°úÍ∑∏ ÏãúÏ†ê
        self.last_signal_log_time = defaultdict(float)
        self.running = True
        self.initial_balance = 0
        self.last_daily_loss_warning = 0  # Ï∂îÍ∞Ä
        self.selling_in_progress = set()
                
        logger.info("=" * 60)
        logger.info("ÏûêÎèôÎß§Îß§ Î¥á Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        logger.info(f"Ï†ÑÎûµ Î™®Îìú: {config.STRATEGY_MODE}")
        logger.info(f"Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®: {config.RISK_LEVEL}")
        logger.info("=" * 60)
    
    async def initialize(self):
        """ÎπÑÎèôÍ∏∞ Ï¥àÍ∏∞Ìôî"""
        # HTTP ÏÑ∏ÏÖò
        self.http_session = aiohttp.ClientSession(
            connector=aiohttp.TCPConnector(limit=30, limit_per_host=15),
            timeout=aiohttp.ClientTimeout(total=8)
        )
        
        # Î™®Îìà Ï¥àÍ∏∞Ìôî
        self.market_data = MarketData(self.http_session, config, self.http_rate)
        self.risk_ctrl = RiskControl(config)
        self.pos_mgr = PositionManager(config, self.market_data, ind)
        self.order_mgr = OrderManager(
            self.upbit, config, self.messenger, 
            self.market_data, self.risk_ctrl
        )
        
        # main_instance Ï†ÑÎã¨
        self.order_mgr.main_instance = self  # ‚Üê Ï∂îÍ∞Ä!

        # Ï¥àÍ∏∞ ÏûîÍ≥† ÎèôÍ∏∞Ìôî
        await self.sync_balances()
        
        # Ïú†ÎãàÎ≤ÑÏä§ Íµ¨ÏÑ±
        await self.build_universe()
        
        logger.info(f"‚úÖ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å | ÏûîÍ≥†: {Utils.fmt_krw(self.balance)}Ïõê | Ïú†ÎãàÎ≤ÑÏä§: {len(self.universe)}Í∞ú")
    
    async def run(self):
        """Î©îÏù∏ Ïã§Ìñâ Î£®ÌîÑ"""
        try:
            await self.initialize()
            
            # Ï¥àÍ∏∞ ÏûîÍ≥† Ï°∞Ìöå
            krw_balance = await asyncio.to_thread(self.upbit.get_balance, "KRW")
            self.initial_balance = krw_balance  # ‚Üê Ïù¥ Ï§Ñ Ï∂îÍ∞Ä
            logger.info(f"Ï¥àÍ∏∞ ÏûîÍ≥†: {self.initial_balance:,.0f}Ïõê")
            
            # Î≥ëÎ†¨ ÏûëÏóÖ ÏãúÏûë
            tasks = [
                asyncio.create_task(self.websocket_handler(), name='websocket'),
                asyncio.create_task(self.signal_processor(), name='signal_processor'),
                asyncio.create_task(self.position_monitor(), name='position_monitor'),
                asyncio.create_task(self.emergency_stop_loss_checker(), name='emergency_sl'),  # Ï∂îÍ∞Ä
                asyncio.create_task(self.periodic_sync(), name='periodic_sync'),
                asyncio.create_task(self.metrics_reporter(), name='metrics'),
                asyncio.create_task(self.dynamic_scanner(), name='dynamic_scanner'), 
            ]
            await asyncio.gather(*tasks)
        
        except asyncio.CancelledError:
            logger.warning("ÏûëÏóÖ Ï∑®ÏÜåÎê®")
        except Exception as e:
            logger.error(f"Ïã§Ìñâ Î£®ÌîÑ Ïò§Î•ò: {e}", exc_info=True)
        finally:
            await self.cleanup()  # Ï†ïÎ¶¨ ÏûëÏóÖ Ìò∏Ï∂ú
    
    async def dynamic_scanner(self):
        """Ï†ÑÏ≤¥ Ï¢ÖÎ™© Ï£ºÍ∏∞Ï†Å Ïä§Ï∫î"""
        while True:
            try:
                await asyncio.sleep(30)
                
                all_tickers = pyupbit.get_tickers(fiat="KRW")
                
                for ticker in all_tickers:
                    if ticker in self.universe:
                        continue
                    try:
                        df = await asyncio.to_thread(
                            pyupbit.get_ohlcv, ticker, interval='minute1', count=5
                        )
                        self.errorcounter[ticker] = 0  # Ï†ïÏÉÅ ÏùëÎãµ Ïãú Ïπ¥Ïö¥ÌÑ∞ Ï¥àÍ∏∞Ìôî(ÏÑ†ÌÉù)
                    except Exception:
                        self.errorcounter[ticker] += 1
                        now = _time.time()
                        if self.errorcounter[ticker] % 10 == 0:
                            logger.warning(f"[{ticker}] ÏµúÍ∑º 10Ìöå Ïó∞ÏÜç orderbook 404 Ïò§Î•ò Î∞úÏÉù (ÎßàÏßÄÎßâ: {datetime.fromtimestamp(now)})")
                            self.lasterrorlogtime[ticker] = now
                        continue
                    if df is None or len(df) < 5:
                        continue
                    change = (df['close'].iloc[-1] / df['close'].iloc[0] - 1)
                    if change >= 0.05: # 5Î∂ÑÍ∞Ñ 5% Í∏âÎì±
                        logger.info(f"üÜï [{ticker}] Í∏âÎì± Í∞êÏßÄ: {change:.2%}")
                        self.universe.append(ticker)
                        self.ws_reconnect_needed = True
            
            except Exception as e:
                logger.error(f"ÎèôÏ†Å Ïä§Ï∫î Ïò§Î•ò: {e}")
    
    async def websocket_handler(self):
        """WebSocket Ïó∞Í≤∞ Î∞è Îç∞Ïù¥ÌÑ∞ ÏàòÏã†"""
        ws_url = "wss://api.upbit.com/websocket/v1"
        
        while True:
            try:
                # Ïú†ÎãàÎ≤ÑÏä§Í∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ ÎåÄÍ∏∞
                if not self.universe:
                    logger.warning("Ïú†ÎãàÎ≤ÑÏä§Í∞Ä ÎπÑÏñ¥ÏûàÏñ¥ WebSocket Ïó∞Í≤∞ Î≥¥Î•ò (10Ï¥à ÎåÄÍ∏∞)")
                    await asyncio.sleep(10)
                    continue
                
                ssl_context = ssl.create_default_context(cafile=certifi.where())
                
                async with websockets.connect(
                    ws_url,
                    ssl=ssl_context,
                    ping_interval=config.PING_INTERVAL,
                    ping_timeout=config.PING_TIMEOUT,
                    close_timeout=config.CLOSE_TIMEOUT
                ) as ws:
                    self.ws_connected = True
                    logger.info(f"üì° WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ (Ïú†ÎãàÎ≤ÑÏä§: {len(self.universe)}Í∞ú)")
                    
                    # Íµ¨ÎèÖ Î©îÏãúÏßÄ
                    subscribe_msg = [
                        {"ticket": "upbit-bot"},
                        {"type": "ticker", "codes": self.universe, "isOnlyRealtime": True},
                        {"type": "orderbook", "codes": self.universe, "isOnlyRealtime": True}
                    ]
                    await ws.send(json.dumps(subscribe_msg))
                    
                    # Îç∞Ïù¥ÌÑ∞ ÏàòÏã† Î£®ÌîÑ
                    while True:
                        data = await ws.recv()
                        await self._process_ws_data(data)
                        self.metrics['ws_received'] += 1
            
            except asyncio.CancelledError:
                logger.info("WebSocket Ìï∏Îì§Îü¨ Ï¢ÖÎ£å")
                break
            except Exception as e:
                self.ws_connected = False
                logger.error(f"WebSocket Ïò§Î•ò: {e}")
                await asyncio.sleep(5)
    
    async def _process_ws_data(self, data: bytes):
        """WebSocket Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨"""
        try:
            msg = json.loads(data)
            msg_type = msg.get('type')
            ticker = msg.get('code')
            
            if msg_type == 'ticker':
                price = float(msg.get('trade_price', 0))
                self.ws_price_cache[ticker] = price
                self.market_data.update_price_cache(ticker, price)
                
                # ===== ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏ Ï†úÍ±∞ =====
                # change_rate = float(msg.get('signed_change_rate', 0))
                # if abs(change_rate) >= 0.01:
                #     logger.info(f"üìà [{ticker}] Î≥ÄÎèô: {change_rate:+.2%} | Í∞ÄÍ≤©: {price:,.0f}Ïõê")
                
                # ===== Î≥¥Ïú† Ï¢ÖÎ™©ÏùÄ Î¨¥Ï°∞Í±¥ ÌÅêÏóê Ï∂îÍ∞Ä =====
                if ticker in self.hold:
                    await self.signal_queue.put(('ticker', ticker, msg))
                else:
                    # Ïã†Ìò∏ ÌõÑÎ≥¥ Ï≤¥ÌÅ¨
                    is_candidate = await self._is_signal_candidate(ticker, msg)
                    if is_candidate:
                        await self.signal_queue.put(('ticker', ticker, msg))
            
            elif msg_type == 'orderbook':
                self.ws_orderbook_cache[(ticker, 2)] = (_time.time(), msg)
              
        except Exception as e:
            Utils.throttled_log('ws_process_error', f"WS Ï≤òÎ¶¨ Ïò§Î•ò: {e}", interval=10)
            

    
    async def _is_signal_candidate(self, ticker: str, msg: dict) -> bool:
        """Ïã†Ìò∏ ÌõÑÎ≥¥ ÌïÑÌÑ∞ÎßÅ (Í∞úÏÑ†)"""
        try:
            change_rate = float(msg.get('signed_change_rate', 0))
            acc_volume = float(msg.get('acc_trade_volume_24h', 0))
            
            # Ï°∞Í±¥ 1: Í∏âÎì±/Í∏âÎùΩ (1.5% ‚Üí ÏôÑÌôî)
            if abs(change_rate) >= 0.015:
                logger.debug(f"[{ticker}] Ï°∞Í±¥1 ÌÜµÍ≥º: Î≥ÄÎèôÎ•† {change_rate:+.2%}")
                return True
            
            # Ï°∞Í±¥ 2: Í±∞ÎûòÎüâ Í∏âÏ¶ù (50Ïñµ Ïù¥ÏÉÅ)
            if acc_volume >= 5_000_000_000:
                logger.debug(f"[{ticker}] Ï°∞Í±¥2 ÌÜµÍ≥º: Í±∞ÎûòÎüâ {acc_volume:,.0f}Ïõê")
                return True
            
            # Ï°∞Í±¥ 3: 5Î∂Ñ Îã®ÏúÑ Î≥ÄÎèô Ï≤¥ÌÅ¨ (Ï∂îÍ∞Ä)
            change_5m = float(msg.get('change_rate', 0))  # 5Î∂Ñ Î≥ÄÎèôÎ•†
            if abs(change_5m) >= 0.01:
                logger.debug(f"[{ticker}] Ï°∞Í±¥3 ÌÜµÍ≥º: 5Î∂Ñ Î≥ÄÎèô {change_5m:+.2%}")
                return True
        
        except Exception as e:
            logger.debug(f"[{ticker}] Ïã†Ìò∏ Ï≤¥ÌÅ¨ Ïò§Î•ò: {e}")
        
        return False
    
    async def signal_processor(self):
        """Ïã†Ìò∏ Ï≤òÎ¶¨ ÏõåÏª§"""
        logger.info("üîÑ Ïã†Ìò∏ Ï≤òÎ¶¨ ÏõåÏª§ ÏãúÏûë")
        
        while True:
            try:
                msg_type, ticker, data = await self.signal_queue.get() 
                
                # Îß§Ïàò Í∞ÄÎä• Ïó¨Î∂Ä Ï≤¥ÌÅ¨
                if ticker not in self.hold:
                    if not self.risk_ctrl.can_trade(ticker):
                        continue 
                    
                    should_buy = await self._evaluate_buy_signal(ticker, data)
                    if should_buy:
                        logger.info(f"[Îß§ÏàòÏã†Ìò∏] {ticker} | Ïã†Ìò∏ ÌåêÎã® Í∑ºÍ±∞: {data}")
                        logger.info(f"[Îß§ÏàòÏßÑÏûÖ] {ticker} | Îç∞Ïù¥ÌÑ∞: {data}")
                        await self._execute_buy(ticker, data)
                    else:
                        now = _time.time()
                        if ticker not in self.last_signal_log_time or (now - self.last_signal_log_time[ticker] > 60):
                            logger.info(f"[Ïã†Ìò∏Î¨¥Ïãú] {ticker} | Îß§Ïàò Ï°∞Í±¥ ÎØ∏Ï∂©Ï°±")
                            self.last_signal_log_time[ticker] = now
                
                # Î≥¥Ïú† Ï§ëÏù¥Î©¥ Îß§ÎèÑ ÌåêÎã®
                else:
                    await self._evaluate_sell_signal(ticker)
            
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Ïã†Ìò∏ Ï≤òÎ¶¨ Ïò§Î•ò: {e}", exc_info=True)
            finally:
                self.signal_queue.task_done()
    
    async def _evaluate_buy_signal(self, ticker: str, data: dict) -> bool:
        """Îß§Ïàò Ïã†Ìò∏ ÌèâÍ∞Ä (Í∞úÏÑ†)"""
        try:
            price = float(data.get('trade_price', 0))
            change_rate = float(data.get('signed_change_rate', 0))
            
            logger.debug(f"[{ticker}] ÌèâÍ∞Ä: Í∞ÄÍ≤©={price:,.0f}, Î≥ÄÎèô={change_rate:+.2%}")
            
            # 1. Fast Spike Ï≤¥ÌÅ¨ (Ï°∞Í±¥ ÏôÑÌôî)
            spike_threshold = config.FAST_SPIKE_MULT * 0.01  # Í∏∞Î≥∏ 3%
            if change_rate >= spike_threshold * 0.5:  # Ï†àÎ∞òÏúºÎ°ú ÏôÑÌôî (1.5%)
                logger.info(f"üöÄ [{ticker}] Fast Spike Í∞êÏßÄ: {change_rate:.2%}")
                return True
            
            # 2. Ï†ÑÎûµ ÏóîÏßÑ ÌèâÍ∞Ä (Í∞ÑÏÜåÌôî)
            try:
                decision = await decide_order(ticker, price, self.market_data, config)
                if decision and decision.get('action') == 'buy':
                    logger.info(f"‚úÖ [{ticker}] Ï†ÑÎûµ ÏóîÏßÑ Îß§Ïàò Ïã†Ìò∏")
                    return True
            except Exception as e:
                logger.debug(f"[{ticker}] Ï†ÑÎûµ ÏóîÏßÑ Ïò§Î•ò: {e}")
            
            # 3. Í∏∞Î≥∏ Ï°∞Í±¥ (Ï∂îÍ∞Ä): 1% Ïù¥ÏÉÅ + Í±∞ÎûòÎüâ
            if abs(change_rate) >= 0.01:
                acc_vol = float(data.get('acc_trade_volume_24h', 0))
                if acc_vol >= 3_000_000_000:  # 30Ïñµ Ïù¥ÏÉÅ
                    logger.info(f"üìä [{ticker}] Í∏∞Î≥∏ Ï°∞Í±¥ Ï∂©Ï°±: {change_rate:+.2%}, Í±∞ÎûòÎüâ {acc_vol/1e9:.1f}B")
                    return True
        
        except Exception as e:
            logger.error(f"[{ticker}] Îß§Ïàò ÌèâÍ∞Ä Ïò§Î•ò: {e}", exc_info=True)
        
        return False
    
    async def _execute_buy(self, ticker: str, data: dict):
        """Îß§Ïàò Ïã§Ìñâ (Ï≤¥Í≤∞ Ï†ïÎ≥¥ Ï†ÄÏû• Í∞úÏÑ†)"""
        try:
            # ===== 1. Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ =====
            position_size = self.risk_ctrl.kelly_position_size(self.balance, volatility=0.02)
            
            # ===== 2. Îß§Ïàò ÏÇ¨Ïú† Ï†ïÏùò =====
            reasons = ['fast_spike']
            
            # ÏµúÎåÄ Ìè¨ÏßÄÏÖò Ï†úÌïú
            max_position = self.risk_ctrl.get_max_position_size(self.balance)
            position_size = min(position_size, max_position)
            
            # ÏµúÏÜå Í∏àÏï° Ï†ÅÏö© (Í∏∞Î≥∏ 5,000Ïõê ‚Üí Îçî ÌÅ∞ Í∞í ÏÇ¨Ïö©)
            min_order = max(config.MIN_ORDER_AMOUNT, self.balance * 0.05)  # ÏûîÍ≥†Ïùò 5%
            position_size = max(position_size, min_order)
            
            # ÏÑ§Ï†ïÎêú ÏµúÎåÄ Í±∞ÎûòÍ∏àÏï° Ï†úÌïú
            position_size = min(position_size, config.MAX_PER_TRADE)
            
            # ===== 3. Îß§Ïàò Î°úÍπÖ =====
            logger.warning(f"üí∞ [{ticker}] Îß§Ïàò ÏãúÎèÑ: {position_size:,.0f}Ïõê / ÏûîÍ≥†: {self.balance:,.0f}Ïõê")
            
            # ===== Îß§Îß§ ÌåêÎã® Î°úÍ∑∏ (Îß§Ïàò ÏãúÎèÑ) =====
            try:
                current_price = float(data.get('trade_price', 0))
                trade_logger.info(
                    f"BUY_ATTEMPT,{ticker},{current_price:.2f},0,{position_size:.0f},"
                    f"{','.join(reasons)},FAST_SPIKE,0,0,0,0,0"
                )
            except Exception as e:
                logger.debug(f"[{ticker}] Îß§Îß§ ÌåêÎã® Î°úÍ∑∏ Ïã§Ìå®: {e}")
    
            # ===== 4. Îß§Ïàò Ïã§Ìñâ =====
            result = await self.order_mgr.buy(
                ticker,
                position_size,
                reasons=reasons,
                strategy='fast_spike'
            )
            
            if not result:
                logger.error(f"‚ùå [{ticker}] Îß§Ïàò Ïã§Ìå®: resultÍ∞Ä None")
                return
            
            # ===== 5. Ï≤¥Í≤∞ Ï†ïÎ≥¥ Ï∂îÏ∂ú (Ï§ëÏöî!) =====
            filled_qty = float(result.get('executed_volume', 0))
            avg_price = float(result.get('avg_price', 0))
            
            # ===== 6. avg_price Í≤ÄÏ¶ù =====
            if avg_price == 0:
                logger.error(f"‚ùå [{ticker}] Ï≤¥Í≤∞Í∞ÄÍ∞Ä 0, Îß§Ïàò Ïã§Ìå®Î°ú Í∞ÑÏ£º")
                return
            
            if filled_qty == 0:
                logger.error(f"‚ùå [{ticker}] Ï≤¥Í≤∞ ÏàòÎüâÏù¥ 0, Îß§Ïàò Ïã§Ìå®Î°ú Í∞ÑÏ£º")
                return
            
            # ===== 7. TP/SL Í≥ÑÏÇ∞ =====
            atr = 0.02 * avg_price  # Í∞ÑÎûµÌôî (Ïã§Ï†úÎ°úÎäî indicatorÏóêÏÑú Í≥ÑÏÇ∞)
            spread_pct = 0.001
            tp, sl = ind.calc_tp_sl_by_atr(avg_price, atr, spread_pct, ticker)
            
            # ===== 8. hold ÎîïÏÖîÎÑàÎ¶¨Ïóê Ï†ÄÏû• (Ï§ëÏöî!) =====
            position_value = filled_qty * avg_price
            
            self.hold[ticker] = {
                'position_id': f"{ticker}-{int(_time.time())}",
                'entry': avg_price,      # ‚Üê Ï≤¥Í≤∞Í∞Ä Ï†ÄÏû•!
                'avgpx': avg_price,
                'avg': avg_price,
                'qty': filled_qty,
                'value': position_value,
                'tp': tp,
                'sl': sl,
                'ts': _time.time(),
                'buy_ts': _time.time(),
                'source': 'order_fill'
            }
            
            # ===== 9. position_manager ÎèôÍ∏∞Ìôî =====
            self.pos_mgr.update_position(ticker, filled_qty, avg_price, tp, sl)
            
            # ===== 10. Î¶¨Ïä§ÌÅ¨ ÎÖ∏Ï∂ú ÏóÖÎç∞Ïù¥Ìä∏ =====
            self.risk_ctrl.update_exposure(position_value, is_add=True)
            
            # ===== 11. Î°úÍπÖ =====
            logger.info(f"[Îß§ÏàòÏ≤¥Í≤∞] {ticker} | ÏàòÎüâ: {filled_qty:.8f} | Ï≤¥Í≤∞Í∞Ä: {avg_price:,.0f} | Ï¥ùÏï°: {position_value:,.0f}")
            logger.info(f"[Ìè¨ÏßÄÏÖòÏ†ÄÏû•] {ticker} | TP: {tp:,.0f} | SL: {sl:,.0f} | entry: {avg_price:,.0f}")
            
            # ===== 12. ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º (ÌòïÏãù Í∞úÏÑ†) =====
            reason_str = ', '.join(reasons) if isinstance(reasons, list) else str(reasons)

            # Ï¢ÖÎ™©Î™Ö Ï∂îÏ∂ú (KRW-BTC -> BTC)
            coin_name = ticker.replace('KRW-', '')

            msg = f"""üí∞ Îß§Ïàò : {coin_name}
            Îß§ÏàòÍ∏àÏï° : {position_value:,}Ïõê
            ÏÇ¨Ïú† : {reason_str}"""

            if hasattr(self, 'messenger') and self.messenger:
                try:
                    await asyncio.to_thread(self.messenger.send_message, msg)
                except Exception as e:
                    logger.warning(f"ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®: {e}")
            
        except Exception as e:
            logger.error(f"[{ticker}] Îß§Ïàò Ïã§Ìñâ Ïò§Î•ò: {e}", exc_info=True)
    
    async def _evaluate_sell_signal(self, ticker: str):
        """Îß§ÎèÑ ÏãúÍ∑∏ÎÑê ÌèâÍ∞Ä"""
        try:
            if ticker not in self.hold:
                return
            
            hold_info = self.hold[ticker]
            
            # ÌòÑÏû¨Í∞Ä Ï°∞Ìöå (market_data ÏÇ¨Ïö©)
            current_price = await self.market_data.get_price(ticker)
            if not current_price:
                # WebSocket Ï∫êÏãúÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
                current_price = self.ws_price_cache.get(ticker)
            
            if not current_price:
                return
            
            entry = float(hold_info.get('entry', 0))
            
            # ÌïòÎìú ÏÜêÏã§ Î¶¨ÎØ∏Ìä∏ (-15%)
            if entry > 0:
                loss_pct = (current_price / entry - 1) * 100.0 
                
                if loss_pct <= -15.0:
                    logger.warning(f"üö® [{ticker}] ÌïòÎìú ÏÜêÏã§ Î¶¨ÎØ∏Ìä∏ ÎèÑÎã¨: {loss_pct:.2f}%")
                    try:
                        await self._execute_sell(ticker, current_price, f'ÌïòÎìúÏÜêÏ†à(-15%)')  # ‚Üê ÏàòÏ†ï
                        if ticker in self.hold:
                            logger.warning(f"‚úÖ [{ticker}] ÌïòÎìú ÏÜêÏ†à ÏôÑÎ£å, Ìè¨ÏßÄÏÖò Ï†úÍ±∞")
                    except Exception as sell_error:
                        logger.error(f"[{ticker}] ÌïòÎìú ÏÜêÏ†à Ïã§Ìñâ Ïã§Ìå®: {sell_error}", exc_info=True)
                    return
                        
            try:
                # ===== ÌÉÄÏûÑÏïÑÏõÉ Ï∂îÍ∞Ä (5Ï¥à) =====
                action, reason = await asyncio.wait_for(
                    self.pos_mgr.should_sell(ticker, current_price, hold_info),
                    timeout=5.0
                )
                logger.warning(f"[DEBUG-SELL] {ticker} should_sell ÏôÑÎ£å: action={action}, reason={reason}")
            except asyncio.TimeoutError:
                logger.error(f"[DEBUG-SELL] {ticker} should_sell ÌÉÄÏûÑÏïÑÏõÉ (5Ï¥à Ï¥àÍ≥º)")
                return
            except Exception as e:
                logger.error(f"[DEBUG-SELL] {ticker} should_sell Ïò§Î•ò: {e}", exc_info=True)
                return
            
            # ÏÜêÏùµÎ•† Í≥ÑÏÇ∞
            pnl_pct = (current_price / entry - 1) * 100.0 if entry > 0 else 0
            
            # ===== Îß§Îß§ ÌåêÎã® Î°úÍ∑∏ (Îß§ÎèÑ ÏãúÍ∑∏ÎÑê) =====
            trade_logger.info(
                f"SELL_SIGNAL,{ticker},{current_price:.2f},0,0,{action},"
                f"{reason},0,0,0,0,0,0,0,{pnl_pct:+.2f},0,{entry:.2f},"
                f"{hold_info.get('tp', 0):.2f},{hold_info.get('sl', 0):.2f}"
            )
        
            logger.info(f"[Îß§ÎèÑÏã†Ìò∏] {ticker} | Í∞ÄÍ≤©: {current_price:.0f} | action: {action} | ÏÇ¨Ïú†: {reason}")
            
            if action == 'sell':
                logger.warning(f"[Îß§ÎèÑÏßÑÏûÖ] {ticker} | Í∞ÄÍ≤©: {current_price:.0f} | ÏÇ¨Ïú†: {reason}")
                await self._execute_sell(ticker, current_price, reason)
            elif action == 'partial':
                logger.warning(f"[Î∂ÄÎ∂ÑÏ≤≠ÏÇ∞] {ticker} | Í∞ÄÍ≤©: {current_price:.0f} | ÏÇ¨Ïú†: {reason}")
                await self._execute_sell(ticker, current_price, reason, partial=True)
                
        except Exception as e:
            logger.error(f"[{ticker}] Îß§ÎèÑ ÏãúÍ∑∏ÎÑê ÌèâÍ∞Ä Ïò§Î•ò: {e}", exc_info=True)
    
    async def _execute_sell(self, ticker: str, price: float, reason: str, partial: bool = False):
        """Îß§ÎèÑ Ïã§Ìñâ (Ï≤¥Í≤∞ Ï†ïÎ≥¥ Í≤ÄÏ¶ù Í∞ïÌôî)"""
        try:
            # ===== 1. Ï§ëÎ≥µ Îß§ÎèÑ Î∞©ÏßÄ =====
            if ticker in self.selling_in_progress:
                logger.warning(f"[{ticker}] Ïù¥ÎØ∏ Îß§ÎèÑ ÏßÑÌñâ Ï§ë, Ïä§ÌÇµ")
                return None
            
            self.selling_in_progress.add(ticker)  # Îß§ÎèÑ ÏãúÏûë
            
            try:
                # ===== 2. hold Ï°¥Ïû¨ ÌôïÏù∏ =====
                if ticker not in self.hold:
                    logger.warning(f"[{ticker}] holdÏóê ÏóÜÏùå, Îß§ÎèÑ Ï§ëÎã®")
                    return None
                
                # ===== 3. ÏßÑÏûÖ Ï†ïÎ≥¥ Ï†ÄÏû• (ÏÜêÏùµ Í≥ÑÏÇ∞Ïö©) =====
                hold_info = self.hold[ticker]
                entry_price = float(hold_info.get('entry', 0))
                position_value = float(hold_info.get('value', 0))
                
                if entry_price == 0:
                    logger.error(f"‚ùå [{ticker}] entry_priceÍ∞Ä 0, ÏÜêÏùµ Í≥ÑÏÇ∞ Î∂àÍ∞Ä")
                    # Í∑∏ÎûòÎèÑ Îß§ÎèÑÎäî ÏßÑÌñâ
                
                # ===== 4. Îß§ÎèÑ Ïã§Ìñâ =====
                qty_ratio = 0.5 if partial else None
                logger.warning(f"[Îß§ÎèÑÏãúÎèÑ] {ticker} | Í∞ÄÍ≤©: {price:,.0f} | ÏÇ¨Ïú†: {reason} | Î∂ÄÎ∂ÑÏ≤≠ÏÇ∞: {partial}")
                
                result = await self.order_mgr.sell(
                    ticker, 
                    price, 
                    reason=reason, 
                    qty_ratio=qty_ratio,
                    final_stage=False
                )
                
                if not result:
                    # ‚úÖ Í∏¥Í∏â ÏÜêÏ†àÏùÄ Ï†ïÏÉÅ ÎèôÏûëÏù¥ÎØÄÎ°ú ÏóêÎü¨ Î†àÎ≤® ÎÇÆÏ∂§
                    if 'Í∏¥Í∏âÏÜêÏ†à' in reason:
                        logger.debug(f"[{ticker}] Í∏¥Í∏â ÏÜêÏ†à ÏôÑÎ£å (ÏÇ¨Ïú†: {reason})")
                    else:
                        logger.error(f"‚ùå [{ticker}] Îß§ÎèÑ Ïã§Ìå®: order_mgr.sellÏù¥ None Î∞òÌôò (ÏÇ¨Ïú†: {reason})")
                    return None
                
                # ===== 5. Ï≤¥Í≤∞ Ï†ïÎ≥¥ Ï∂îÏ∂ú =====
                filled_qty = float(result.get('executed_volume', 0))
                avg_price = float(result.get('avg_price', 0))
                paid_fee = float(result.get('paid_fee', 0))
                
                # ===== 6. Í≤ÄÏ¶ù =====
                if avg_price == 0 or filled_qty == 0:
                    logger.error(f"‚ùå [{ticker}] Îß§ÎèÑ Ï≤¥Í≤∞Í∞Ä/ÏàòÎüâÏù¥ 0 (Ï≤¥Í≤∞Í∞Ä: {avg_price}, ÏàòÎüâ: {filled_qty})")
                    return None
                
                # ===== 7. ÏÜêÏùµ Í≥ÑÏÇ∞ =====
                total_value = filled_qty * avg_price
                
                if entry_price > 0:
                    pnl_pct = (avg_price / entry_price - 1) * 100.0
                    pnl_krw = filled_qty * (avg_price - entry_price) - paid_fee
                else:
                    pnl_pct = 0.0
                    pnl_krw = 0.0
                    logger.warning(f"[{ticker}] entry_price=0, ÏÜêÏùµ Í≥ÑÏÇ∞ Î∂àÍ∞Ä")
                
                # ===== 8. Í±∞Îûò Í≤∞Í≥º Í∏∞Î°ù =====
                self.risk_ctrl.record_trade_result(ticker, pnl_pct, pnl_krw)
                
                # ===== 9. Î°úÍπÖ =====
                logger.warning(f"[Îß§ÎèÑÏ≤¥Í≤∞] {ticker} | ÏàòÎüâ: {filled_qty:.8f} | Ï≤¥Í≤∞Í∞Ä: {avg_price:,.0f} | Ï¥ùÏï°: {total_value:,.0f} | ÏÜêÏùµ: {pnl_pct:+.2f}% ({pnl_krw:+,.0f}Ïõê)")
                
                # ===== Îß§Îß§ ÌåêÎã® Î°úÍ∑∏ (Îß§Ïàò Ï≤¥Í≤∞) =====
                trade_logger.info(
                    f"SELL_FILLED,{ticker},{avg_price:.2f},{filled_qty:.8f},"
                    f"{total_value:.0f},{reason},0,{pnl_pct:+.2f},{pnl_krw:+.0f},"
                    f"{entry_price:.2f},0,0"
                )

                # ===== 10. ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º (ÌòïÏãù Í∞úÏÑ†) =====
                emoji = "üí∞" if pnl_krw >= 0 else "üìâ"

                # Ï¢ÖÎ™©Î™Ö Ï∂îÏ∂ú (KRW-BTC -> BTC)
                coin_name = ticker.replace('KRW-', '')

                msg = f"""{emoji} Îß§ÎèÑ : {coin_name}
                Îß§ÎèÑÍ∏àÏï° : {total_value:,}Ïõê
                Îß§ÎèÑÏÜêÏùµ : {pnl_krw:+,.0f}Ïõê ({pnl_pct:+.2f}%)
                ÏÇ¨Ïú† : {reason}"""

                if hasattr(self, 'messenger') and self.messenger:
                    try:
                        await asyncio.to_thread(self.messenger.send_message, msg)
                    except Exception as e:
                        logger.warning(f"ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®: {e}")
                
                # ===== 11. Ìè¨ÏßÄÏÖò Ï†ïÎ¶¨ (Ï†ÑÎüâ Ï≤≠ÏÇ∞ Ïãú) =====
                if not partial:
                    # Î¶¨Ïä§ÌÅ¨ ÎÖ∏Ï∂ú ÏóÖÎç∞Ïù¥Ìä∏
                    self.risk_ctrl.update_exposure(position_value, is_add=False)
                    
                    # holdÏóêÏÑú Ï†úÍ±∞
                    if ticker in self.hold:
                        del self.hold[ticker]
                        logger.info(f"[{ticker}] holdÏóêÏÑú Ï†úÍ±∞ ÏôÑÎ£å")
                    
                    # explode Î™®Îìú Ìï¥Ï†ú
                    if hasattr(self.pos_mgr, 'deactivate_explode_mode'):
                        self.pos_mgr.deactivate_explode_mode(ticker)
                else:
                    # Î∂ÄÎ∂Ñ Ï≤≠ÏÇ∞ Ïãú ÏàòÎüâÎßå ÏóÖÎç∞Ïù¥Ìä∏
                    if ticker in self.hold:
                        remaining_qty = self.hold[ticker].get('qty', 0) - filled_qty
                        self.hold[ticker]['qty'] = max(0, remaining_qty)
                        self.hold[ticker]['value'] = remaining_qty * entry_price
                        logger.info(f"[{ticker}] Î∂ÄÎ∂Ñ Ï≤≠ÏÇ∞ ÌõÑ ÎÇ®ÏùÄ ÏàòÎüâ: {remaining_qty:.8f}")
                
                return result
            
            finally:
                # ===== 12. Îß§ÎèÑ ÏôÑÎ£å ÌõÑ Ï†úÍ±∞ =====
                self.selling_in_progress.discard(ticker)
        
        except Exception as e:
            logger.error(f"[{ticker}] Îß§ÎèÑ Ïã§Ìñâ Ïò§Î•ò: {e}", exc_info=True)
            self.selling_in_progress.discard(ticker)  # ÏóêÎü¨ ÏãúÏóêÎèÑ Ï†úÍ±∞
            return None
    
    async def position_monitor(self):
        """Ìè¨ÏßÄÏÖò Î™®ÎãàÌÑ∞ÎßÅ (Ï§ëÎ≥µ Îß§ÎèÑ Î∞©ÏßÄ + Í∏¥Í∏â ÏÜêÏ†à)"""
        last_daily_loss_warning = 0
        last_eval_time = {}
        last_emergency_sell = {}  # ‚Üê Í∏¥Í∏â ÏÜêÏ†à Ïø®Îã§Ïö¥ Ï∂îÍ∞Ä
        
        while self.running:
            try:
                await asyncio.sleep(1)
                now = _time.time()
                
                # ===== 1. invalid entry Ï†úÍ±∞ =====
                for ticker in list(self.hold.keys()):
                    hold_info = self.hold.get(ticker, {})
                    entry = float(hold_info.get('entry', 0))
                    qty = float(hold_info.get('qty', 0))
                    
                    # entry=0 ÎòêÎäî qty=0Ïù∏ Í≤ΩÏö∞ Ï†úÍ±∞
                    if entry == 0 or qty == 0:
                        logger.warning(f"[CLEANUP] {ticker} invalid entry/qty Í∞êÏßÄ, holdÏóêÏÑú Ï†úÍ±∞: entry={entry}, qty={qty}")
                        if ticker in self.hold:
                            del self.hold[ticker]
                        continue
                
                logger.info(f"[DEBUG-MON] position_monitor Ïã§Ìñâ Ï§ë, hold Í∞úÏàò: {len(self.hold)}")
                
                # ===== 2. ÏùºÏùº ÏÜêÏã§ Ï≤¥ÌÅ¨ (60Ï¥àÎßàÎã§) =====
                daily_loss = self.risk_ctrl.daily_loss_krw
                daily_loss_limit = self.initial_balance * self.config.DAILY_LOSS_LIMIT_PCT
                
                if daily_loss >= daily_loss_limit: 
                    if now - last_daily_loss_warning >= 300:
                        logger.warning(f"‚ö†Ô∏è ÏùºÏùºÏÜêÏã§ ÌïúÎèÑ ÎèÑÎã¨: {daily_loss:,.0f}Ïõê / ÌïúÎèÑ: {daily_loss_limit:,.0f}Ïõê")
                        last_daily_loss_warning = now
                    continue
                
                # ===== 3. Í∏¥Í∏â ÏÜêÏ†à Ï≤¥ÌÅ¨ (Î™®Îì† Ìè¨ÏßÄÏÖò) =====
                for ticker in list(self.hold.keys()):
                    try:
                        # ===== Ï§ëÎ≥µ Îß§ÎèÑ Î∞©ÏßÄ =====
                        if ticker in self.selling_in_progress:
                            #logger.debug(f"[{ticker}] Ïù¥ÎØ∏ Îß§ÎèÑ ÏßÑÌñâ Ï§ë, Í∏¥Í∏â ÏÜêÏ†à Ïä§ÌÇµ")
                            continue
                        
                        # ===== 5Ï¥àÎßàÎã§ 1Î≤àÎßå ÌèâÍ∞Ä =====
                        if now - last_eval_time.get(ticker, 0) < 5:
                            continue
                        
                        # ===== Í∏¥Í∏â ÏÜêÏ†à Ïø®Îã§Ïö¥ (5Ï¥à) =====
                        if now - last_emergency_sell.get(ticker, 0) < 5:
                            continue
                        
                        hold_info = self.hold.get(ticker, {})
                        entry = float(hold_info.get('entry', 0))
                        sl = float(hold_info.get('sl', 0))
                        
                        if entry == 0 or sl == 0:
                            continue
                        
                        # ÌòÑÏû¨Í∞Ä Ï°∞Ìöå
                        current_price = self.ws_price_cache.get(ticker)
                        if not current_price:
                            continue
                        
                        # ===== Í∏¥Í∏â ÏÜêÏ†à Ï°∞Í±¥ ÌôïÏù∏ =====
                        if current_price <= sl:
                            logger.warning(f"üö® [{ticker}] Í∏¥Í∏â ÏÜêÏ†à: {current_price:,.0f} <= SL {sl:,.0f}")
                            
                            # ‚úÖ Ïø®Îã§Ïö¥ ÏóÖÎç∞Ïù¥Ìä∏ (Îß§ÎèÑ ÏãúÎèÑ Ï†Ñ)
                            last_emergency_sell[ticker] = now
                            
                            # ‚úÖ ÏóêÎü¨ Î°úÍ∑∏ Ï†úÍ±∞ (Î∂àÌïÑÏöî)
                            await self._execute_sell(ticker, current_price, f"Í∏¥Í∏âÏÜêÏ†à (SL={sl:.0f})")
                            continue
                        
                    except Exception as e:
                        logger.error(f"[{ticker}] Í∏¥Í∏â ÏÜêÏ†à Ï≤¥ÌÅ¨ Ïò§Î•ò: {e}", exc_info=True)
                
                # ===== 4. ÏùºÎ∞ò Îß§ÎèÑ Ïã†Ìò∏ ÌèâÍ∞Ä (5Ï¥àÎßàÎã§) =====
                for ticker in list(self.hold.keys()):
                    try:
                        # ===== Ï§ëÎ≥µ Îß§ÎèÑ Î∞©ÏßÄ =====
                        if ticker in self.selling_in_progress:
                            continue
                        
                        # ===== 5Ï¥àÎßàÎã§ 1Î≤àÎßå ÌèâÍ∞Ä =====
                        if now - last_eval_time.get(ticker, 0) < 5:
                            continue
                        
                        last_eval_time[ticker] = now
                        await self._evaluate_sell_signal(ticker)
                        
                    except Exception as e:
                        logger.error(f"[{ticker}] Îß§ÎèÑ ÌèâÍ∞Ä Ïò§Î•ò: {e}", exc_info=True)
                        
            except Exception as e:
                logger.error(f"Ìè¨ÏßÄÏÖò Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò: {e}", exc_info=True)
                if not self.running:
                    break
    
    async def emergency_stop_loss_checker(self):
        """Í∏¥Í∏â ÏÜêÏ†à Ï≤¥ÌÅ¨ (Ïã§ÏãúÍ∞Ñ)"""
        while self.running:   
            try:
                await asyncio.sleep(0.5)  # 0.5Ï¥àÎßàÎã§ Ï≤¥ÌÅ¨
                
                # ÏùºÏùº ÏÜêÏã§ Ï≤¥ÌÅ¨ (1Î∂ÑÏóê 1Î≤àÎßå Í≤ΩÍ≥†)
                #now = _time.time()
                #if self.risk_ctrl.is_daily_loss_limit_reached():  # ‚Üê ÏàòÏ†ï
                #    if now - self.last_daily_loss_warning >= 60:
                #        daily_loss = self.risk_ctrl.get_daily_loss()  # ‚Üê ÏàòÏ†ï
                #        logger.warning(f"‚ö†Ô∏è ÏùºÏùº ÏÜêÏã§ ÌïúÎèÑ ÎèÑÎã¨: {daily_loss:,.0f}Ïõê")
                #        self.last_daily_loss_warning = now
                
                for ticker in list(self.hold.keys()):
                    price = self.ws_price_cache.get(ticker)
                    if not price:
                        logger.debug(f"[DEBUG] {ticker} Í∞ÄÍ≤© Ï∫êÏãú ÏóÜÏùå")
                        continue
                    
                    hold_info = self.hold[ticker]
                    entry = float(hold_info.get('entry', 0))
                    sl = float(hold_info.get('sl', entry * (1 - config.SL_PCT_DEFAULT)))
                    
                    # ÏÜêÏ†àÍ∞Ä ÎèÑÎã¨ Ï¶âÏãú Îß§ÎèÑ
                    if price <= sl:
                        logger.warning(f"‚ö†Ô∏è [{ticker}] Í∏¥Í∏â ÏÜêÏ†à Ïã§Ìñâ: ÌòÑÏû¨Í∞Ä {price:,.0f} <= SL {sl:,.0f}")
                        # ===== DEBUG: Îß§ÎèÑ Ï†Ñ ÏÉÅÌÉú Ï≤¥ÌÅ¨ =====
                        logger.warning(f"[DEBUG] {ticker} Îß§ÎèÑ ÏãúÎèÑ Ï†Ñ ÏÉÅÌÉú:")
                        logger.warning(f"  - hold_info: {hold_info}")
                        logger.warning(f"  - price: {price}")
                        logger.warning(f"  - entry: {entry}")
                        logger.warning(f"  - sl: {sl}")
                        # ===== Îß§ÎèÑ Ïã§Ìñâ ÌõÑ holdÏóêÏÑú Ï¶âÏãú Ï†úÍ±∞ =====
                        try:
                            result = await self._execute_sell(ticker, price, f'Í∏¥Í∏âÏÜêÏ†à (SL={sl:,.0f})') 
                            # ===== DEBUG: Îß§ÎèÑ Í≤∞Í≥º Ï≤¥ÌÅ¨ =====
                            logger.warning(f"[DEBUG] {ticker} Îß§ÎèÑ Í≤∞Í≥º: {result}")
                            # Îß§ÎèÑ ÌõÑ holdÏóêÏÑú Ï†úÍ±∞ (Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ)
                            if result:
                                logger.warning(f"‚úÖ [{ticker}] Í∏¥Í∏â ÏÜêÏ†à ÏôÑÎ£å")
                                # holdÏóêÏÑú Ï†úÍ±∞
                                if ticker in self.hold:
                                    del self.hold[ticker]
                            else:
                                logger.error(f"‚ùå [{ticker}] Í∏¥Í∏â ÏÜêÏ†à Ïã§Ìå®: resultÍ∞Ä None")
                        except Exception as sell_error:
                            logger.error(f"[{ticker}] Í∏¥Í∏â ÏÜêÏ†à Ïã§Ìñâ Ïã§Ìå®: {sell_error}", exc_info=True)                                 
                        
            except Exception as e:
                logger.error(f"Í∏¥Í∏â ÏÜêÏ†à Ï≤¥ÌÅ¨ Ïò§Î•ò: {e}", exc_info=True)
                if not self.running:
                    break
    
    async def cleanup(self):
        """Ï†ïÎ¶¨ ÏûëÏóÖ (asyncio Ï¢ÖÎ£å Ïò§Î•ò Ìï¥Í≤∞)"""
        logger.info("Î¥á Ï¢ÖÎ£å Ï§ë...")
        self.running = False
        
        try:
            # ===== 1. WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å =====
            try:
                if hasattr(self, 'ws') and self.ws:
                    await self.ws.close()
                    logger.info("WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å")
            except Exception as e:
                logger.error(f"WebSocket Ï¢ÖÎ£å Ïò§Î•ò: {e}")
            
            # ===== 2. Î™®Îì† Ìè¨ÏßÄÏÖò Í∞ïÏ†ú Ï≤≠ÏÇ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠) =====
            if self.hold:
                logger.warning(f"Î≥¥Ïú† Ìè¨ÏßÄÏÖò {len(self.hold)}Í∞ú Í∞êÏßÄ")
                for ticker in list(self.hold.keys()):
                    try:
                        price = await self.market_data.get_price(ticker)
                        if price:
                            await self._execute_sell(ticker, price, 'Í∞ïÏ†úÏ≤≠ÏÇ∞(Ï¢ÖÎ£å)', partial=False)
                    except Exception as e:
                        logger.error(f"[{ticker}] Í∞ïÏ†úÏ≤≠ÏÇ∞ Ïã§Ìå®: {e}")
            
            # ===== 3. ÎåÄÍ∏∞ Ï§ëÏù∏ Task Ï∑®ÏÜå (ÌïµÏã¨ ÏàòÏ†ï!) =====
            try:
                current_task = asyncio.current_task()
                tasks = [
                    t for t in asyncio.all_tasks() 
                    if t != current_task and not t.done()
                ]
                
                if tasks:
                    logger.info(f"Ï∑®ÏÜåÌï† Task Í∞úÏàò: {len(tasks)}")
                    
                    # Task Ï∑®ÏÜå
                    for task in tasks:
                        task.cancel()
                    
                    # Task Ï∑®ÏÜå ÎåÄÍ∏∞ (ÌÉÄÏûÑÏïÑÏõÉ 5Ï¥à)
                    done, pending = await asyncio.wait(tasks, timeout=5.0)
                    
                    if pending:
                        logger.warning(f"‚ö†Ô∏è Ï∑®ÏÜåÎêòÏßÄ ÏïäÏùÄ Task: {len(pending)}Í∞ú")
                        # Í∞ïÏ†ú Ï∑®ÏÜå
                        for task in pending:
                            task.cancel()
                    else:
                        logger.info(f"‚úÖ Î™®Îì† Task Ï∑®ÏÜå ÏôÑÎ£å: {len(done)}Í∞ú")
            
            except Exception as e:
                logger.error(f"Task Ï∑®ÏÜå Ïò§Î•ò: {e}")
            
            # ===== 4. SQLite Ïó∞Í≤∞ Ï¢ÖÎ£å =====
            try:
                for handler in logger.handlers:
                    if isinstance(handler, SQLiteHandler):
                        handler.close()
                        logger.info("SQLite Ìï∏Îì§Îü¨ Ï¢ÖÎ£å")
            except Exception as e:
                logger.error(f"SQLite Ìï∏Îì§Îü¨ Ï¢ÖÎ£å Ïò§Î•ò: {e}")
            
            logger.warning("‚úÖ Ï†ïÎ¶¨ ÏûëÏóÖ ÏôÑÎ£å")
            
        except Exception as e:
            logger.error(f"Ï†ïÎ¶¨ ÏûëÏóÖ Ïò§Î•ò: {e}", exc_info=True)
    
    async def periodic_sync(self):
        """Ï£ºÍ∏∞Ï†Å ÎèôÍ∏∞Ìôî (ÏûîÍ≥†, Ïú†ÎãàÎ≤ÑÏä§)"""
        while True:
            try:
                await asyncio.sleep(config.SYNC_INTERVAL_SEC)
                
                now = _time.time()
                if now - self.last_sync_ts >= 60:
                    await self.sync_balances()
                    self.last_sync_ts = now
                
                # Ïú†ÎãàÎ≤ÑÏä§ Ïû¨ÌèâÍ∞Ä (4ÏãúÍ∞ÑÎßàÎã§)
                if now % config.UNIVERSE_REEVAL_SEC < config.SYNC_INTERVAL_SEC:
                    await self.build_universe()
            
            except Exception as e:
                logger.error(f"ÎèôÍ∏∞Ìôî Ïò§Î•ò: {e}")
    
    async def sync_balances(self):
        """ÏûîÍ≥† ÎèôÍ∏∞Ìôî"""
        try:
            balances = await asyncio.to_thread(self.upbit.get_balances)
            krw_balance = 0.0
            
            for b in balances:
                currency = b['currency']
                if currency == 'KRW':
                    krw_balance = float(b['balance'])
                else:
                    ticker = f"KRW-{currency}"
                    qty = float(b['balance'])
                    avg_price = float(b.get('avg_buy_price', 0))
                    
                    if qty > 0 and ticker not in self.hold:
                        # Ïô∏Î∂Ä Ìè¨ÏßÄÏÖò Í∞êÏßÄ
                        price = await self.market_data.get_price(ticker)
                        if price:
                            self.pos_mgr.update_position(ticker, qty, avg_price or price)
                            self.hold[ticker] = self.pos_mgr.hold[ticker]
            
            self.balance = krw_balance
            self.risk_ctrl.set_initial_balance(krw_balance)
        
        except Exception as e:
            logger.error(f"ÏûîÍ≥† ÎèôÍ∏∞Ìôî Ïò§Î•ò: {e}")
    
    async def build_universe(self):
        """Í±∞Îûò Ïú†ÎãàÎ≤ÑÏä§ Íµ¨ÏÑ±"""
        try:
            # MarketAnalyzerÏùò Ïã§Ï†ú Î©îÏÑúÎìú ÏÇ¨Ïö© (ÎπÑÎèôÍ∏∞ ÎûòÌïë)
            top_coins = await asyncio.to_thread(
                self.market_analyzer.get_top_coins,
                top_n=config.UNIVERSE_TARGET_COUNT,
                min_volume=config.UNIVERSE_MIN_VOL24H
            )
            
            # top_coinsÎäî List[Tuple[str, Dict]] ÌòïÌÉú Î∞òÌôò
            # Ïòà: [('KRW-BTC', {...}), ('KRW-ETH', {...})]
            if top_coins:
                self.universe = [ticker for ticker, _ in top_coins]
                logger.info(f"üåê Ïú†ÎãàÎ≤ÑÏä§ Í∞±Ïã†: {len(self.universe)}Í∞ú")
                if len(self.universe) >= 5:
                    logger.info(f"   ÏÉÅÏúÑ 5Í∞ú: {', '.join(self.universe[:5])}")
                else:
                    logger.info(f"   Ï†ÑÏ≤¥: {', '.join(self.universe)}")
            else:
                raise Exception("Î∂ÑÏÑùÎêú ÏΩîÏù∏Ïù¥ ÏóÜÏäµÎãàÎã§")
        
        except Exception as e:
            logger.error(f"Ïú†ÎãàÎ≤ÑÏä§ Íµ¨ÏÑ± Ïò§Î•ò: {e}", exc_info=True)
            
            # Ìè¥Î∞±: Í∏∞Î≥∏ Î©îÏù¥Ï†Ä ÏΩîÏù∏ Î¶¨Ïä§Ìä∏
            self.universe = [
                'KRW-BTC', 'KRW-ETH', 'KRW-XRP', 'KRW-SOL', 'KRW-DOGE',
                'KRW-ADA', 'KRW-AVAX', 'KRW-MATIC', 'KRW-LINK', 'KRW-DOT',
                'KRW-ATOM', 'KRW-NEAR', 'KRW-APT', 'KRW-SUI', 'KRW-ARB'
            ]
            logger.warning(f"‚ö†Ô∏è Ìè¥Î∞± Ïú†ÎãàÎ≤ÑÏä§ ÏÇ¨Ïö©: {len(self.universe)}Í∞ú")
    
    async def metrics_reporter(self):
        """Î©îÌä∏Î¶≠ Î¶¨Ìè¨ÌåÖ"""
        while True:
            try:
                await asyncio.sleep(60)
                
                msg = f"üìä Î©îÌä∏Î¶≠ | WSÏàòÏã†: {self.metrics['ws_received']} | "
                msg += f"Ìè¨ÏßÄÏÖò: {len(self.hold)} | ÏûîÍ≥†: {Utils.fmt_krw(self.balance)}Ïõê"
                
                Utils.throttled_log('metrics', msg, interval=300)
            
            except Exception as e:
                logger.error(f"Î©îÌä∏Î¶≠ Î¶¨Ìè¨ÌåÖ Ïò§Î•ò: {e}")
    
    async def cleanup(self):
        """Ï†ïÎ¶¨ ÏûëÏóÖ"""
        logger.info("üßπ Ï†ïÎ¶¨ ÏûëÏóÖ ÏãúÏûë...")
        
        if self.http_session:
            await self.http_session.close()
        
        logger.info("‚úÖ Ï†ïÎ¶¨ ÏôÑÎ£å")
        

# ============================================================
# 8. Î©îÏù∏ ÏóîÌä∏Î¶¨ Ìè¨Ïù∏Ìä∏
# ============================================================
def main():
    """Î©îÏù∏ ÏóîÌä∏Î¶¨ Ìè¨Ïù∏Ìä∏"""
    bot = TradingBot()
    try:
        asyncio.run(bot.run())
    except KeyboardInterrupt:
        logger.info("üõë ÌîÑÎ°úÍ∑∏Îû® Ï¢ÖÎ£å")
    except Exception as e:
        logger.critical(f"‚ùå ÏπòÎ™ÖÏ†Å Ïò§Î•ò: {e}", exc_info=True)
        logging.activate_debug_mode()   # Ïò§Î•ò Í∞êÏßÄ Ïãú DEBUG Î°úÍ∑∏ ÏûÑÏãú ÌôúÏÑ±Ìôî

if __name__ == '__main__':
    bot = None
    try:
        bot = TradingBot()
        asyncio.run(bot.run())
    except KeyboardInterrupt:
        logger.warning("üõë KeyboardInterrupt Í∞êÏßÄ, Ï†ïÏÉÅ Ï¢ÖÎ£å ÏãúÏûë...")
        if bot:
            # ÎπÑÎèôÍ∏∞ Ï†ïÎ¶¨ ÏûëÏóÖ
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    loop.stop()
                    loop.close()
            except Exception as e:
                logger.error(f"Ïù¥Î≤§Ìä∏ Î£®ÌîÑ Ï¢ÖÎ£å Ïò§Î•ò: {e}")
    except Exception as e:
        logger.error(f"ÏπòÎ™ÖÏ†Å Ïò§Î•ò: {e}", exc_info=True)
    finally:
        logger.warning("üîö ÌîÑÎ°úÍ∑∏Îû® Ï¢ÖÎ£å")
        sys.exit(0)
